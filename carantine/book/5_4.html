<HTML>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<LINK REL=STYLESHEET TYPE="text/css" href="mystyle.css">
  </head>
  <body>
<p>
    <a href='5_3.html'>Назад</a> 
    <a href='Menu5.html'>Зміст</a>
    <a href='5_5.html'>Вперед</a>
</p>
    <h1>Задачі на зміну цифр натурального числа</h1>
<p>Згадаємо, що десяткова система числення є позиційною. В позиційній системі числення значення кожної цифри залежить від її позиції –  місця у числі.</p>
<p>Число 4131 насправді має таки склад:</p>
<p>4131=4*1000+1*100+3*10+1=4*10<sup>3</sup>+1*10<sup>2</sup>+3*10<sup>1</sup></sup>+1*10<sup>0</sup>  </p>
<p>Число 10, степені якого використовуються у цій формулі називається основою системи числення, а степені десятки – це вага цифри.</p>

<h2>Приклад 1</h2>
<p>Дано натуральне число. Змініть у ньому всі цифри 1 на 2.</p>
<h3>Результат роботи програми</h3>
<table align=center>
<tr><th>Ввід</th> <th>Вивід</th> </tr>
<tr><td>4131</td> <td>4232</td></tr>
</table>

<h3>Змінні:</h3>
<p>Вхідні: </p>
<ul>
<li>n – натуральне число (цілого типу Longint)
</ul>
<p>Вихідні:</p>
<ul>
<li>m – нове натуральне число, в якому замість 1 стоять 2 (цілого типу Longint)
</ul>
<p>Проміжні:</p>
<ul>
<li>c – остання  цифра числа (цілого типу byte)
<li>d – вага цифри у числі – 1, 10, 100, 1000, ... (цілого типу Longint)
</ul>
<h3>Алгоритм</h3>
<p>Скорочений алгоритм формування з введеного числа n нового числа m такий: </p>
<ul>
<li>Знаходимо c останню цифру числа n;
<li>Якщо ця цифра 1, змінюємо її на 2, якщо ні, то не змінюємо;
<li>Додаємо цю цифру c в початок нового числа m (враховуючі вагу цифри d).
<li>Відкидаємо цифру з числа n.
<li>Все це повторюємо, поки не закінчаться цифри у числі n.
</ul>
<p>Щоб визначити формули, за якими будуть обчислюватись m та d складемо таблицю для нашого прикладу:</p>
<table align=center>
<tr><th>Змінна</th> <th>c</th> <th>m</th> <th>d</th> <th>n</th> </tr>
<tr><td>Дія</td> <td>Обчислення останньої цифри </td> <td>Накопичуємо цифру у початок числа</td> <td>Вага цифри, степені числа 10</td> <td>Відкидаємо останню цифру</td></tr>
<tr><td>Початкове значення</td> <td>&nbsp;</td><td>0</td> <td>1</td> <td>4131</td></tr>
<tr><td>1 виток циклу</td> <td>1 змінюємо на 2</td> <td>2</td> <td>10</td> <td>413</td></tr>
<tr><td>2 виток циклу</td> <td>3</td> <td>32=3*10+2</td> <td>100</td> <td>41</td></tr>
<tr><td>3 виток циклу</td> <td>1 змінюємо на 2</td> <td>232=2*100+32</td> <td>1000</td> <td>4</td></tr>
<tr><td>Останній виток циклу</td> <td>4</td> <td>	4232=4*1000+232</td> <td>10000</td> <td>0</td></tr>
<tr><td>Формули</td> <td>c:=n mod 10</td> <td>m := c*d + m</td> <td>d:=d*10</td> <td>n:=n div 10</td></tr>
</table>
<p>Аналізуючи третій стовпчик таблиці можна заповнити комірку, де буде формула для обчислення нового числа m. Ясно, що для додавання цифри c у початок нового числа m потрібно умножати її на вагу d  і цей добуток накопичувати у нове число m.  </p>
<p>Формула для обчислення степенів числа 10 нам відома. Можна записати її у четвертому стовпчику. </p>
<p>Тепер алгоритм докладніше: </p>
<ol>
<li>Спочатку потрібно ввести число оператором read(n).
<li>Нам потрібно сформувати нове число m. Ми будемо його накопичувати, як суму, тому потрібно встановити початкове значення m:=0.
<li>Ми будемо використовувати d вагу цифри у числі. Ми будемо її накопичувати, як добуток, тому потрібно встановити початкове значення d:=1.
<li>У вже відомий нам алгоритм перебору цифр числа, додамо два оператори (обчислення m та d), які умовно можна назвати „формування нового числа”. Докладніше, у циклі будемо виконувати такі дії:
<ul>
<li>Оператор c:= n mod 10 обчислює останню цифру числа. 
<li>Оператор if c=1 then c:=2 змінює цифру 1 на 2. 
<li>Оператор m:=m+c*d  додає знайдену  цифру у початок нового числа, враховуючі її вагу.
<li> Оператор d:=d*10  обчислює вагу наступної цифри.
<li>Оператор n:=n div 10 відкидає останню  цифру числа. 
<li>Перевіряється умова n=0 – чи є ще цифри у числі? 
<ul>
<li>Якщо умова не вірна, тобто цифри у числі є, то виконується перехід на початок циклу (пункт 4).
<li>Якщо умова вірна, тобто цифр у числі немає, то цикл завершується і виконується перехід на оператор, що іде після циклу (пункт 5).
</ul>
</ul>
<li>Коли цикл закінчиться, тобто будуть видалені всі цифри числа n виводимо на екран знайдене нове число оператором writeln(m).
</ol>
<h3>Блок–схема програми</h3>
<h4 align=center><img src="5_4/image001.gif"></h4>
<h3>Програма</h3>
<table align=center>
<tr><td>
var n,m,d:longint; c:byte;<br>
begin<br>
read(n);<br>
m:=0; d:=1;<br>
repeat<br>
c:=n mod 10; <br>
if c=1 then c:=2;<br>
m:=m+c*d; d:=d*10;<br>
n:=n div 10;<br>
until n=0;<br>
writeln(m);<br>
end.
</td></tr>
</table>


<h2>Приклад 2</h2>
<p>Дано натуральне число n. Вилучить у ньому всі 1.</p>
<h3>Результат роботи програми</h3>
<table align=center>
<tr><th>Ввід</th> <th>Вивід</th> </tr>
<tr><td>4131</td> <td>43</td></tr>
</table>
<h3>Змінні:</h3>
<p>Вхідні: </p>
<ul>
<li>n – натуральне число (цілого типу Longint)
</ul>
<p>Вихідні:</p>
<ul>
<li>m – нове натуральне число, в якому немає 1 (цілого типу Longint)
</ul>
<p>Проміжні:</p>
<ul>
<li>c – остання  цифра числа (цілого типу byte)
<li>d – вага цифри у числі – 1, 10, 100, 1000, ... (цілого типу Longint)
</ul>
<h3>Алгоритм</h3>
<p>Алгоритм формування з введеного числа n нового числа m без 1 відрізняється від алгоритму попередньої задачі тим, що оператори, які ми назвали „формування нового числа” виконуються тільки, коли цифра, яка переноситься у нове число не 1. Якщо цифра дорівнює 1, то ці оператори не виконуються і цифра в нове число не переноситься.</p>
<p>Тепер алгоритм докладніше: </p>
<ol>
<li>Спочатку потрібно ввести число оператором read(n).
<li>Встановимо початкове значення нового числа m:=0.
<li>Встановимо початкове значення ваги d:=1.
<li>У циклі будемо виконувати такі дії:
<ul>
<li>Оператор c:= n mod 10 обчислює останню цифру числа. 
<li>Якщо ця цифра не 1 (оператор if c<>1 then ),то переносимо її у нове число: 
<ul>
<li>Оператор m:=m+c*d  додає знайдену  цифру у початок нового числа, враховуючі її вагу.
<li> Оператор d:=d*10  обчислює вагу наступної цифри.
</ul>
<li>Оператор n:=n div 10 відкидає останню  цифру числа n. 
<li>Перевіряється умова n=0 – чиє ще цифри у числі? 
<ul>
<li>Якщо умова не вірна, тобто цифри у числі є, то виконується перехід на початок циклу (пункт 4).
<li>  Якщо умова вірна, тобто цифру числі немає, то цикл завершується і виконується перехід на оператор, що іде після циклу (пункт 5).
</ul>
</ul>
<li>Коли цикл закінчиться, тобто будуть видалені всі цифри числа n виводимо на екран знайдене нове число оператором writeln(m).
</ol>
<h3>Програма</h3>
<table align=center>
<tr><td>
var n,m,d:longint; c:byte;<br>
begin<br>
read(n);<br>
m:=0; d:=1;<br>
repeat<br>
c:=n mod 10;<br>
if c<>1 then<br>
begin<br>
m:=m+c*d; d:=d*10;<br>
end;<br>
n:=n div 10;<br>
until n=0;<br>
writeln(m);<br>
end.
</td></tr>
</table>

<h2>Приклад 3</h2>
<p>Дано натуральне число n. Переверніть число. Наприклад, з числа 3456 одержати 6543.</p>
<h3>Результат роботи програми</h3>
<table align=center>
<tr><th>Ввід</th> <th>Вивід</th> </tr>
<tr><td>3456</td> <td>6543</td></tr>
</table>

<h3>Змінні:</h3>
<p>Вхідні: </p>
<ul>
<li>n – натуральне число (цілого типу Longint)
</ul>
<p>Вихідні:</p>
<ul>
<li>m – нове перевернуте натуральне число (цілого типу Longint)
</ul>
<p>Проміжні:</p>
<ul>
<li>c – остання  цифра числа (цілого типу byte)
</ul>
<h3>Алгоритм</h3>
<p>Скорочений алгоритм формування з введеного числа n нового числа m такий: </p>
<ul>
<li>Знаходимо c останню цифру числа n;
<li>Додаємо цю цифру c у кінець нового числа m (для додавання цифри у кінець числа, потрібно число умножити на 10 та додати цифру).
<li>Відкидаємо цифру з числа n.
<li>Все це повторюємо, поки не закінчаться цифри у числі n.
</ul>
<p>Щоб визначити формулу, за якою буде обчислюватись m складемо таблицю для нашого прикладу:</p>
<table align=center>
<tr><th>Змінна</th> <th>c</th> <th>m</th>  <th>n</th> </tr>
<tr><td>Дія</td> <td>Обчислення останньої цифри </td> <td>Накопичуємо цифру у початок числа</td> <td>Відкидаємо останню цифру</td></tr>
<tr><td>Початкове значення</td> <td>&nbsp;</td><td>0</td> <td>3456</td></tr>
<tr><td>1 виток циклу</td> <td>6</td> <td>6</td> <td>345</td></tr>
<tr><td>2 виток циклу</td> <td>5</td> <td>65=6*10+5</td> <td>34</td></tr>
<tr><td>3 виток циклу</td> <td>4</td> <td>654=65*10+4</td>  <td>3</td></tr>
<tr><td>Останній виток циклу</td> <td>3</td> <td>	6543=654*10+3</td>  <td>0</td></tr>
<tr><td>Формули</td> <td>c:=n mod 10</td> <td>m:= m*10+c </td>  <td>n:=n div 10</td></tr>
</table>
<p>Аналізуючи третій стовпчик таблиці можна заповнити комірку, де буде формула для обчислення нового числа m. Ясно що для додавання цифри c у кінець нового числа m потрібно число m умножати  на 10 та додавати  да нього знайдену цифру с. </p>
<p>Тепер алгоритм докладніше: </p>
<ol>
<li>Спочатку потрібно ввести число оператором read(n).
<li>Нам потрібно сформувати нове число m. Ми будемо його накопичувати, як суму, тому потрібно встановити початкове значення m:=0.
<li>У цьому прикладі у відомий нам алгоритм перебору цифр числа, додамо один оператор (обчислення m), який умовно можна назвати „формування перевернутого числа”. Докладніше, у циклі будемо виконувати такі дії:
<ul>
<li>Оператор c:= n mod 10 обчислює останню цифру числа. 
<li>Оператор m:=m*10+c додає знайдену  цифру у кінець нового числа.
<li>Оператор n:=n div 10 відкидає останню  цифру числа. 
<li>Перевіряється умова n=0 – чи є ще цифри у числі? 
<ul>
<li>Якщо умова не вірна, тобто цифри у числі є, то виконується перехід на початок циклу (пункт 3).
<li>Якщо умова вірна, тобто цифр у числі немає, то цикл завершується і виконується перехід на оператор, що іде після циклу (пункт 4).
</ul>
</ul>
<li>Коли цикл закінчиться, тобто будуть видалені всі цифри числа n виводимо на екран знайдене нове число оператором writeln(m).
</ol>
<h3>Програма</h3>
<table align=center>
<tr><td>
var n,m:longint; c:byte;<br>
begin<br>
read(n); m:=0;<br>
repeat<br>
c:=n mod 10;<br>
m:=m*10+c;<br>
n:=n div 10; <br>
until n=0;<br>
writeln(m)<br>
end.
</td></tr>
</table>


<h2>Приклад 4</h2>
<p>Дано натуральне число. Припишіть 5 в початок цього числа. Наприклад, було 324, стало 5324.</p>
<h3>Результат роботи програми</h3>
<table align=center>
<tr><th>Ввід</th> <th>Вивід</th> </tr>
<tr><td>324</td> <td>5324</td></tr>
</table>

<h3>Змінні:</h3>
<p>Вхідні: </p>
<ul>
<li>n – натуральне число (цілого типу Longint)
</ul>
<p>Вихідні:</p>
<ul>
<li>m – нове натуральне число з 5 на початку числа (цілого типу Longint)
</ul>
<p>Проміжні:</p>
<ul>
<li>d – вага цифри 5 у числі – 1, 10, 100, 1000, ... (цілого типу Longint)
<li>x – для запам’ятовування  числа n (цілого типу Longint)
</ul>
<h3>Алгоритм</h3>
<p>Щоб отримати нове число m, потрібно цифру 5 помножити на її вагу у новому числі (у прикладі на 1000) та до цього добутку додати введене число n (у прикладі  5*1000+324=5324). </p>
<p>Задача зводиться до пошуку d ваги цифри 5 у новому числі. Для цього у циклі d  умножаємо на 10, стільки разів, скільки цифр у числі. Як-то:</p>
</p>
<ul>
<li>виконуємо оператор d:=d*10.
<li>Відкидаємо цифру з числа n.
<li>Все це повторюємо, поки не закінчаться цифри у числі n.
</ul>
<p>Тепер алгоритм докладніше: </p>
<ol>
<li>Спочатку потрібно ввести число оператором read(n).
<li>Введене  число n нам буде потрібно в остаточній формулі. Але ми будемо від нього відкидати цифри для пошуку ваги цифри 5 у новому числі. Тому це число потрібно запам’ятати оператором x:=n.
<li>Ми будемо використовувати d вагу цифри 5 у новому числі. Її потрібно накопичувати, як добуток, тому потрібно встановити початкове значення d:=1.
<li>У циклі знаходимо вагу цифри 5 у новому числі. Для цього будемо виконувати такі дії:
<ul>
<li>Оператор d:=d*10  обчислює вагу наступної цифри.
<li>Оператор n:=n div 10 відкидає останню  цифру числа n. 
<li>Перевіряється умова n=0 – чиє ще цифри у числі? 
<ul>
<li>Якщо умова не вірна, тобто цифри у числі є, то виконується перехід на початок циклу (пункт 4).
<li>  Якщо умова вірна, тобто цифру числі немає, то цикл завершується і виконується перехід на оператор, що іде після циклу (пункт 5).
</ul>
</ul>
<li>Коли цикл закінчиться, обчислимо значення нового числа оператором m:=5*d+x. У цій формулі використовуємо x замість n, тому що значення n вже 0.
<li>Потім виводимо на екран знайдене нове число оператором writeln(m).
</ol>
<h3>Програма</h3>
<table align=center>
<tr><td>
var n,m,d,x:longint;<br>
begin<br>
read(n);x:=n;<br>
d:=1;<br>
repeat<br>
d:=d*10;<br>
n:=n div 10;<br>
until n=0;<br>
m:=5*d+x;<br>
writeln(m);<br>
end.
</td></tr>
</table>
<h2>Варіанти задач</h2>
<ol>
<li>Дано натуральне число. Змініть у ньому всі цифри a на b.
<li>Дано натуральне число. Вилучить з нього всі цифри a. 
<li>Дано натуральне число. З’ясуйте, чи є воно паліндромом (перевернуте число дорівнює введеному).
<li>Дано натуральне число. Припишіть цифру a в початок цього числа.
<li>Дано натуральне число. Припишіть по двійці в початок та кінець цього числа.
<li>Дано натуральне число. Припишіть цифру a в початок та цифру b у кінець цього числа.
<li>Дано натуральне число. Вилучити з нього всі цифри, що співпадають з останньою цифрою. 
<li>Дано натуральне число. Вилучити з нього тільки першу цифру. 
<li>Дано натуральне число. Вилучити з нього всі входження першої цифри. 
<li>Дано натуральне число. Припишіть до нього таке ж саме число.
<li>Дано натуральне число n. Припишіть до нього число m.
<li>Дано натуральне число n. Припишіть до нього число m в початок та кінець цього числа.
<li>Дано натуральне число. Вилучити з нього всі входження мінімальної цифри. 
<li>Дано натуральне число. Вилучити з нього максимальну  цифру. Якщо максимальних цифр декілька (39892), то вилучити останню максимальну(3982). 
<li>Дано натуральне число. Сформуйте нове число, в якому перед кожною цифрою 1 вставлена цифра 0 (наприклад, було 3141 стало 301401).
<li>Дано натуральне число. Переставте його першу та останню цифри.
</ol>
<p>
     <a href='5_3.html'>Назад</a> 
    <a href='Menu5.html'>Зміст</a>
    <a href='5_5.html'>Вперед</a>
</p>
  </body>
</HTML>
        
                             
     
  




