<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<LINK REL=STYLESHEET TYPE="text/css" href="mystyle.css">. 
</head>
<body>

<p> <a href="3_5.html"> Назад </a> 
    <a href="Menu3.html">Зміст </a> 
    <a href="3_7.html">Вперед </a> 
</p>
<h1> Складена умова</h1>
<p> 
Складена умова – дві або більше простих умови, з’єднаних знаком логічної операції (and, or, xor, not). 
</p>
<p>
<b>Прості умови потрібно брати в дужки!</b>
</p>
<h3> Приклад </h3>
<p> (X>0)and(y=2*z)or(z+2=x+y)xor not(x>y)</p>
<h3>Пріоритет виконання операцій у логічних виразах:</h3>
<table align=center>
<tr> <th>Пріоритет операції </th> <th>Операція </th></tr>
<tr> <th> 1</th><th>	У дужках </th><tr>
<tr> <th>2	 </th> <th>/ , * </th><tr>
<tr> <th>3	 </th> <th>+,  – </th><tr>
<tr> <th>4 </th> <th>=,  > , < , <br>>= , <=,  <> </th><tr>
<tr> <th>5	 </th><th> Not </th><tr>
<tr> <th>6	 </th><th> And </th><tr>
<tr> <th>7	</th> <th>or, xor </th><tr>
</table>
<p>
У вказаному прикладі, спочатку обчислюються математичні вирази: у дужках виконаються операції „+” та „*”, потім обчислюються прості умови (виконуються операції “>”, “=” ), потім  виконується логічна операція not, потім логічна операція and, потім логічні операції or та xor, у тому порядку, що вони записані.
</p>

<h2>Логічна операція AND  (і, та, кожне, обидва) </h2>

<p>Складена умова  <b>(проста  умова 1) and ( проста умова 2)  </b>вірна, якщо вірні обидві простих умови. У інших випадках  така складена умова невірна. 
</p>
<h3>Таблиця істинності логічної операції  and </h3>
<table align=center>
<tr> <th>Значення умови 1</th> <th>Значення умови 2</th> <th>Значення результату</th></tr>
<tr> <td>TRUE</td><td>TRUE	</td><td>TRUE</td></tr>
<tr> <td>FALSE</td><td>FALSE</td><td>FALSE</td></tr>
<tr> <td>FALSE</td><td>TRUE</td><td>FALSE</td></tr>
<tr> <td>TRUE</td><td>FALSE</td><td>FALSE</td></tr>
</table>
<p>
Обчислюючи складену умову з логічною операцією and, можна не перевіряти значення другої умови, якщо одна з умов має значення FALSE . Весь вираз буде мати значення FALSE.
</p>
<p>
Операцію and  називають логічним множенням 
</p>
<h3>Приклади складання умов з логічною операцією AND  </h3>
<table align=center>
<tr> <th>Ствердження</th> <th> Умова</th></tr>
<tr> <td>Число X належіть інтервалу <br> [-2, 5], тобто -2<=x<=5 </td><td>(x>=-2)and(x<=5)</td></tr>
<tr> <td>Ціле число X двозначне </td><td> (x div 100=0)and(x div 10=0)</td></tr>
<tr> <td>Натуральне число X кратно 7 <br>та закінчується цифрою 3 </td><td>(x mod 7=0)and(x mod 10=3)</td></tr>
<tr> <td>Кожне з двох цілих чисел X та Y парне </td><td> (x mod 2=0)and(y mod 2=0)</td></tr>
<tr> <td>Точка з координатами x, y попадає <br>в заштриховану ділянку площини. <br><IMG SRC ="3_6\image001.gif"> </td><td>(x>=-3)and(x<=-1) and (y>=1)and(y<=3)</td></tr>
</table>
<h3>Приклади обчислення логічних виразів з логічною операцією AND  </h3>
<table align=center>
<tr> <th width=300>Програма </th> <th> 	Пояснення </th> <th> Результат роботи </th></tr>
<tr> <td>Const X=10;<br>
Var Z:Boolean;<br>
Begin<br>
Z:=(x>2)and(x<5); <br>
writeln(z);<br>
end.
</td> <td>	X=10, тому x>2 вірно, а x<5 невірно, тому і весь вираз невірний.</td> <td> FALSE</td></tr>
<tr> <td>Const a=2; b=2;c=3;<br>
Var Z:Boolean;<br>
Begin<br>
Z:=(a>0)and(b>0)and(c>0);<br>
writeln(z);<br>
end.</td> <td>	a=2; b=2; c=3, тому a>0 вірно, b>0 вірно, c>0 вірно, тому і весь вираз вірний.</td> <td>TRUE</td></tr>
</table>
<h2>Логічна операція OR (або, хоча б одне) </h2>
<p>
Складена умова <b> (проста  умова 1) or (проста  умова 2) </b>невірна, якщо невірні обидві простих умови. 
</p>
<p>
У інших випадках  така складена умова вірна. 
</p>
<h3>Таблиця істинності логічної операції  or  </h3>
<table align=center>
<tr> <th>Значення умови 1</th> <th>Значення умови 2</th> <th>Значення результату</th></tr>
<tr> <td> FALSE</td><td> FALSE</td><td> FALSE</td></tr>
<tr> <td> TRUE </td><td> TRUE </td><td> TRUE </td></tr>
<tr> <td>FALSE</td><td>TRUE</td><td> TRUE </td></tr>
<tr> <td>TRUE</td><td>FALSE</td><td> TRUE </td></tr>
</table>
<p>
Обчислюючи складену умову з логічною операцією or, можна не перевіряти значення другої умови, якщо одна з умов має значення TRUE . Весь вираз буде мати значення TRUE.
</p>
<p>
Операцію or називають логічнм додаванням 
</p>
<h3>Приклади складання умов з логічною операцією OR  </h3>
<table align=center>
<tr> <th width=100>Ствердження</th> <th width=400>Умова </th></tr>
<tr> <td>Хоча б одне з чисел X та Y додатне</td><td>(x>0)or(y>0)</td></tr>
<tr> <td>Натуральне число X закінчується цифрою 2 або 3	</td><td>(x mod 10=2)or(x mod 10=3)</td></tr>
<tr> <td>Точка з координатами X та Y належить I або IIІ чверті координатної площини.</td><td>(X>0)and(y>0)or(x<0)and(y<0)</td></tr>
</table>
<h3>Приклади обчислення логічних виразів з логічною операцією OR  </h3>
<table align=center>
<tr> <th width=500>Програма	</th> <th width=300>Пояснення</th> <th>	Результат роботи</th></tr>
<tr> <td> 
Const X=1; y=-1;<br>
Var Z:Boolean;<br>
Begin<br>
Z:=(x*y<0)or(y>x);<br> writeln(z);<br>
end.
</td><td>	
 X=1; y=-1, <br>
тому x*y<0 вірно, і незалежно від значення другої простої умови весь вираз вірний.
</td><td>	
TRUE
</td></tr>
<tr> <td> 
Const x=1; y=1;<br>
Var Z:Boolean;<br>
Begin<br>
Z:=(x*x+y*y<4)or(x>=2)and(x<=4)and(y>=2)and(y<=4);<br>
writeln(z);<br>
end.
</td><td>
Спочатку обчислюється значення виразу (x>=2)and(x<=4)and(y>=2)and(y<=4), а потім значення виразу x*x+y*y<4.
Але значення останнього виразу TRUE, тому незалежно від значення першого виразу весь вираз вірний.	
</td><td>
TRUE
</td></tr>
</table>
<h2>Логічна операція XOR (тільки одне, при різних)</h2>
<p>
Складена умова  <b>(проста умова 1) xor (проста умова 2) </b>вірна, при різних значеннях операндів. При однакових значеннях  операндів така складена умова невірна. 
</p>
<h3>Таблиця істинності логічної операції  xor  </h3>
<table align=center>
<tr> <th>Значення умови 1</th> <th>Значення умови 2</th> <th>Значення результату</th></tr>
<tr> <td> FALSE</td><td> FALSE</td><td> FALSE </td></tr>
<tr> <td> TRUE </td><td> TRUE </td><td> FALSE </td></tr>
<tr> <td>FALSE</td><td>TRUE</td><td> TRUE </td></tr>
<tr> <td>TRUE</td><td>FALSE</td><td> TRUE </td></tr>
</table>
<p>Обчислюючи складену умову з логічною операцією xor, потрібно перевіряти значення обох умов. </p>
<p>Логічну операцію xor називають „исключающее или”. Без цієї операції можна обійтись, але її використання значно скорочує запис.
</p>
<h3>Приклад складання умови з логічною операцією XOR </h3>
<table align=center>
<tr> <th>Ствердження</th> <th>Умова без xor</th> <th>Умова з xor</th></tr>
<tr> <td> Тільки одне з чисел X та Y парне
</td><td>
(x mod 2=0)and(y mod 2<>0) or (x mod 2<>0)and(y mod 2=0)	
</td><td>(x mod 2=0) xor
(y mod 2=0)</td></tr>
</table>
<h3>Приклади обчислення логічних виразів з логічною операцією XOR </h3>
<table align=center>
<tr> <th width=350>Програма </th> <th>	Пояснення</th> <th>Результат роботи</th></tr>
<tr> <td>Const  X=1; y=-1;<br>
Var Z:Boolean;<br>
Begin<br>
Z:=(x*y<1)xor(y>x); <br>writeln(z);<br>
end.</td><td>X=1; y=-1, <br>
тому x*y<1 вірно, а y>x невірно. Тобто прості умови мають різні значення, тому весь вираз вірний.	</td><td>TRUE</td></tr>
<tr> <td> Const X=1; y=2;<br>
Var Z:Boolean;<br>
Begin<br>
Z:=(x*y<3)xor(y>x);<br>
writeln(z);<br>
end.</td><td>X=1; y=2;
тому x*y<3 вірно, а y>x вірно. Тобто прості умови мають однакові вірні значення, тому весь вираз невірний.</td><td>	FALSE</td></tr>
<tr> <td> Const X=2; y=1;<br>
Var Z:Boolean;<br>
Begin<br>
Z:=(x*y=3)xor(y>x)and(x+y>2);<br>
writeln(z);<br>
end.</td><td>X=2; y=1;<br>
Спочатку обчислюється значення простих умов:<br>
x*y=3 невірно<br>
y>x невірно<br>
x+y>2 вірно.<br>
Потім обчислюється логічна операція and. (y>x)and(x+y>2)–невірно.
Тоді перша умова невірна, друга умова невірна, значенні однакові і весь вираз невірний.</td><td>
FALSE</td></tr>
</table>
<h2>Логічний префікс NOT (не).</h2>

<p>Складена умова  <b>not (умова 1) </b>вірна, якщо (умова 1) невірна. І навпаки,  складена умова невірна, якщо (умова 1) вірна.

<h3>Таблиця істинності логічної операції not </h3>
<table align=center>
<tr> <th>Значення умови 1</th> <th>Значення результату</th></tr>
<tr> <td>FALSE</td><td>TRUE</td></tr>
<tr> <td>TRUE</td><td>FALSE</td></tr>
</table>

<h3>Приклади складання умов з логічною операцією NOT </h3>
<table align=center>
<tr> <th width=40%>Ствердження</th> <th width=30%>Умова без not</th> <th width=30%>Умова з not</th></tr>
<tr> <td>Число X не належіть інтервалу [-2, 5].</td><td>(x<-2)or(x>5)</td><td>Not((x>=-2)and(x<=5))</td></tr>
<tr> <td>Ціле число X не ділиться на 3.	</td><td>X mod 3<>0</td><td>Not (x mod 3=0)</td></tr>
</table>

<h3>Приклади обчислення логічних виразів з логічною операцією NOT </h3>
<table align=center>
<tr> <th width=30%>Програма </th> <th>	Пояснення</th> <th>Результат роботи</th></tr>
<tr> <td>
Const X=10; <br>
Var Z:Boolean;<br>
Begin<br>
Z:=not((x>=1)and(x<=5));<br>
writeln(z);<br>
end.
</td><td>
Операція not стоїть перед дужками, тому спочатку виконуються дії у дужках.
X=10;
Тому (x>=1)and(x<=5) – невірно, а весь вираз вірний.
</td><td>
TRUE
</td></tr>
<tr> <td> 
Const X=10; <br>
Var Z:Boolean;<br>
Begin<br>
Z:=not(x>=1)and(x<=5);<br>
writeln(z);<br>
end.

</td><td>
У цьому випадку not відноситься тільки до перших дужок. 
X=10;
Тому x>=1 – вірно
not(x>=1) –невірно.
Наступна операція and, у якої перша умова невірна, тому значення другої умови можна не обчислювати, весь вираз буде невірний
</td><td>
FALSE
</td></tr>

</table>
<p> <a href="3_5.html"> Назад </a> 
    <a href="Menu3.html">Зміст </a> 
    <a href="3_7.html">Вперед </a> 
</p>
</body>
</html>



































</html>